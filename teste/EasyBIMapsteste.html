<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>EasyBIMaps - Visualizador e Editor GeoJSON</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Leaflet CSS & JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
  <!-- leaflet-image.js -->
  <script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { min-height: 300px; }
    .CodeMirror { height: 100%; min-height: 300px; border-radius: 0.5rem; }
    .message-box { position: fixed; top: 1rem; right: 1rem; z-index: 9999; }
  </style>
</head>
<body class="h-screen w-screen bg-gray-100">
  <div class="flex flex-col md:flex-row h-screen w-screen">
    <!-- Painel de Controles -->
    <aside class="md:w-1/5 w-full bg-white shadow-lg rounded-r-2xl p-4 flex flex-col gap-4">
      <h2 class="text-xl font-bold mb-2">Controles</h2>
      <input type="file" id="fileInput" multiple accept=".geojson,.json" class="mb-2" />
      <ul id="layerList" class="mb-2"></ul>
      <div id="stylePanel" class="hidden flex flex-col gap-2 p-2 bg-gray-50 rounded-lg shadow"></div>
      <button id="exportGeojson" class="mt-2 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Exportar como GeoJSON</button>
      <!-- Campo para nome do arquivo final -->
      <div class="mt-2 flex flex-col gap-2">
        <label class="flex items-center gap-2">Nome do arquivo:
          <input type="text" id="exportFileName" value="EasyBIMaps" class="border rounded px-2 py-1" style="width:180px;">
        </label>
      </div>
    </aside>
    <!-- Painel do Mapa -->
    <main class="md:w-2/5 w-full flex-1 flex flex-col">
      <div id="map" class="flex-1 rounded-2xl shadow-lg m-4"></div>
    </main>
    <!-- Painel do Editor removido -->
    <!-- Painel de Visualização de Estilo -->
    <aside class="md:w-1/5 w-full p-4 flex flex-col gap-2">
      <h2 class="text-lg font-bold mb-2">Visualização do Código GeoJSON</h2>
      <div id="stylePreview" class="bg-gray-50 rounded-lg shadow p-2 text-xs overflow-auto max-h-48 select-none"></div>
    </aside>
  </div>
  <div id="messageBox" class="message-box hidden bg-black text-white px-4 py-2 rounded shadow-lg"></div>
  <script>
    // --- Variáveis Globais ---
    let map, editor, layers = [], activeLayerIndex = null;
    // --- Inicialização do Mapa ---
    map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
  // --- Editor removido ---
    // --- Função de Mensagem Flutuante ---
    function showMessage(msg, type = 'info', timeout = 3000) {
      const box = document.getElementById('messageBox');
      box.textContent = msg;
      box.classList.remove('hidden');
      box.classList.remove('bg-black','bg-red-600','bg-green-600');
      box.classList.add(type === 'error' ? 'bg-red-600' : (type === 'success' ? 'bg-green-600' : 'bg-black'));
      setTimeout(() => box.classList.add('hidden'), timeout);
    }
    // --- Renderização da Lista de Camadas ---
    function renderLayerList() {
      const ul = document.getElementById('layerList');
      ul.innerHTML = '';
      layers.forEach((layerObj, idx) => {
        const li = document.createElement('li');
        li.className = `flex items-center justify-between mb-1 px-2 py-1 rounded cursor-pointer ${activeLayerIndex===idx?'bg-blue-100':'hover:bg-gray-200'}`;
        li.innerHTML = `<span class="truncate" title="${layerObj.name}">${layerObj.name}</span>`;
        li.onclick = () => setActiveLayer(idx);
        const removeBtn = document.createElement('button');
        removeBtn.className = 'ml-2 text-red-600 hover:text-red-800 font-bold';
        removeBtn.textContent = 'Remover';
        removeBtn.onclick = (e) => { e.stopPropagation(); removeLayer(idx); };
        li.appendChild(removeBtn);
        ul.appendChild(li);
      });
      renderStylePreview();
    }
    // --- Adicionar Camada GeoJSON ---
    function addGeoJsonLayer(geojson, name = 'GeoJSON', style = {}) {
      let leafletLayer;
      function styleFunc(feature) {
        const s = feature.properties && feature.properties._style ? feature.properties._style : style;
        return {
          color: s.color || '#3388ff',
          weight: s.weight || 3,
          opacity: s.opacity || 1,
          fillColor: s.fillColor || '#3388ff',
          fillOpacity: s.fillOpacity || 0.2,
          radius: s.radius || 8
        };
      }
      leafletLayer = L.geoJSON(geojson, {
        style: styleFunc,
        pointToLayer: function(feature, latlng) {
          const s = feature.properties && feature.properties._style ? feature.properties._style : style;
          return L.circleMarker(latlng, styleFunc(feature));
        }
      }).addTo(map);
      layers.push({ name, geojson, leafletLayer, style });
      setActiveLayer(layers.length-1);
      renderLayerList();
      fitLayerBounds(leafletLayer);
    }
    // --- Ajustar Mapa para Camada ---
    function fitLayerBounds(layer) {
      try {
        const bounds = layer.getBounds();
        if (bounds.isValid()) map.fitBounds(bounds);
      } catch {}
    }
    // --- Remover Camada ---
    function removeLayer(idx) {
      map.removeLayer(layers[idx].leafletLayer);
      layers.splice(idx,1);
      if (activeLayerIndex === idx) activeLayerIndex = null;
      else if (activeLayerIndex > idx) activeLayerIndex--;
      renderLayerList();
      renderStylePanel();
    }
    // --- Ativar Camada ---
    function setActiveLayer(idx) {
      activeLayerIndex = idx;
      renderLayerList();
      renderStylePanel();
    }
    // --- Renderizar Painel de Estilo ---
    function renderStylePanel() {
      const panel = document.getElementById('stylePanel');
      if (activeLayerIndex === null || layers.length === 0) {
        panel.classList.add('hidden');
        panel.innerHTML = '';
        return;
      }
      panel.classList.remove('hidden');
      // Define todos os atributos de estilo com valores padrão se não existirem
      const style = layers[activeLayerIndex].style;
      const defaultStyle = {
  color: '#3388ff',
  weight: 3,
  opacity: 1,
  fillColor: '#3388ff',
  fillOpacity: 0.2,
  radius: 8
      };
      Object.keys(defaultStyle).forEach(key => {
        if (typeof style[key] === 'undefined') style[key] = defaultStyle[key];
      });
      panel.innerHTML = `
        <h3 class="font-bold mb-2">Estilo do GeoJSON</h3>
        <label class="flex items-center gap-2">Cor da Linha: <input type="color" id="color" value="${style.color||'#3388ff'}"></label>
        <label class="flex items-center gap-2">Espessura: <input type="range" id="weight" min="1" max="10" value="${style.weight||3}"></label>
        <label class="flex items-center gap-2">Opacidade da Linha: <input type="range" id="opacity" min="0" max="1" step="0.05" value="${style.opacity||1}"></label>
        <label class="flex items-center gap-2">Cor do Preenchimento: <input type="color" id="fillColor" value="${style.fillColor||'#3388ff'}"></label>
        <label class="flex items-center gap-2">Opacidade do Preenchimento: <input type="range" id="fillOpacity" min="0" max="1" step="0.05" value="${style.fillOpacity||0.2}"></label>
        <label class="flex items-center gap-2">Raio dos Pontos: <input type="range" id="radius" min="1" max="30" value="${style.radius||8}"></label>
      `;
      ['color','weight','opacity','fillColor','fillOpacity','radius'].forEach(attr => {
        panel.querySelector(`#${attr}`).oninput = (e) => {
          style[attr] = attr==='weight'||attr==='radius'?parseInt(e.target.value):(attr.includes('Opacity')?parseFloat(e.target.value):e.target.value);
          updateLayerStyle(activeLayerIndex);
        };
      });
    }
    // --- Atualizar Estilo da Camada ---
    function updateLayerStyle(idx) {
      const layerObj = layers[idx];
      layerObj.leafletLayer.setStyle(function(feature) {
        feature.properties = feature.properties || {};
        feature.properties._style = layerObj.style;
        return {
          color: layerObj.style.color || '#3388ff',
          weight: layerObj.style.weight || 3,
          opacity: layerObj.style.opacity || 1,
          fillColor: layerObj.style.fillColor || '#3388ff',
          fillOpacity: layerObj.style.fillOpacity || 0.2,
          radius: layerObj.style.radius || 8
        };
      });
      // Atualiza circleMarker
      layerObj.leafletLayer.eachLayer(function(l) {
        if (l instanceof L.CircleMarker) {
          l.setStyle({ radius: layerObj.style.radius });
        }
      });
      renderStylePreview();
    }
    // --- Carregar Arquivos ---
    document.getElementById('fileInput').addEventListener('change', function(e) {
      Array.from(e.target.files).forEach(file => {
        const reader = new FileReader();
        reader.onload = function(evt) {
          try {
            const geojson = JSON.parse(evt.target.result);
            addGeoJsonLayer(geojson, file.name);
            showMessage(`Arquivo ${file.name} carregado!`, 'success');
          } catch (err) {
            showMessage(`Erro ao carregar ${file.name}: ${err.message}`, 'error');
          }
        };
        reader.readAsText(file);
      });
      e.target.value = '';
    });
    // --- Exportar Tudo como GeoJSON ---
    document.getElementById('exportGeojson').onclick = function() {
      if (layers.length === 0) return showMessage('Nenhuma camada para exportar!', 'error');
      let fileName = document.getElementById('exportFileName').value.trim();
      if (!fileName) fileName = 'EasyBIMaps';
      fileName += '.geojson';
      // Aplica estilização completa no início das propriedades de todas as features de todos os arquivos
      const defaultStyle = {
        color: '#3388ff',
        weight: 3,
        opacity: 1,
        fillColor: '#3388ff',
        fillOpacity: 0.2,
        radius: 8
      };
      const allFeatures = layers.flatMap(layerObj => {
        let style = { ...defaultStyle, ...layerObj.style };
        // Adiciona stroke e stroke-width ao final
        style.stroke = style.color;
        style['stroke-width'] = style.weight;
        // LOG para depuração
        console.log('Exportando camada:', layerObj.name, 'Estilo exportado:', style);

        function addStrokeProps(props) {
          props.stroke = props.color;
          props['stroke-width'] = props.weight;
          return props;
        }

        if (layerObj.geojson.type === 'FeatureCollection') {
          return layerObj.geojson.features.map(f => {
            const featureCopy = JSON.parse(JSON.stringify(f));
            featureCopy.properties = featureCopy.properties || {};
            // Adiciona stroke e stroke-width ao final das propriedades da feature
            featureCopy.properties = addStrokeProps({ ...style, ...featureCopy.properties });
            return featureCopy;
          });
        } else if (layerObj.geojson.type === 'Feature') {
          const featureCopy = JSON.parse(JSON.stringify(layerObj.geojson));
          featureCopy.properties = featureCopy.properties || {};
          featureCopy.properties = addStrokeProps({ ...style, ...featureCopy.properties });
          return [featureCopy];
        }
        return [];
      });
      // Monta o GeoJSON final
      const geojsonString = '{\n"type": "FeatureCollection",\n"features": [\n' +
        allFeatures.map(f => JSON.stringify(f)).join(',\n') + '\n]\n}';
      const blob = new Blob([geojsonString], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      showMessage('GeoJSON exportado!', 'success');
    };
    // --- Responsividade ---
    function handleResize() {
      const h = window.innerHeight;
      document.getElementById('map').style.height = (h - 32) + 'px';
      // document.getElementById('editor').style.height = (h - 80) + 'px';
    }
    window.addEventListener('resize', handleResize);
    handleResize();
    function renderStylePreview() {
  const preview = document.getElementById('stylePreview');
  if (!preview) return;
  let out = '<div style="font-family:monospace; width:100%;">';
  layers.forEach(layerObj => {
    const style = layerObj.style || {};
    out += `<div style='margin-bottom:1.5em;'>`;
    out += `<div style='font-size:1.1em;font-weight:bold;margin-bottom:0.5em;'>${layerObj.name}</div>`;
    Object.entries(style).forEach(([k,v]) => {
      if ((k === 'color' || k === 'fillColor' || k === 'stroke') && typeof v === 'string' && v.startsWith('#')) {
        out += `<div style='font-weight:bold; margin-left:1em; margin-bottom:0.2em;'>${k}: <span style='font-weight:normal;'>${v}</span> <span style='display:inline-block;width:18px;height:18px;border-radius:4px;border:1px solid #ccc;vertical-align:middle;background:${v};margin-left:6px;'></span></div>`;
      } else {
        out += `<div style='font-weight:bold; margin-left:1em; margin-bottom:0.2em;'>${k}: <span style='font-weight:normal;'>${typeof v==='string'?v:v}</span></div>`;
      }
    });
    out += `</div>`;
  });
  out += '</div>';
  preview.innerHTML = out;
  preview.style.fontSize = '1em';
  preview.style.overflowX = 'auto';
  preview.style.maxHeight = 'none';
  preview.style.height = 'auto';
  preview.style.width = '100%';
}
    // --- Função para trocar a ordem das camadas ---
function moveLayer(fromIdx, toIdx) {
  if (fromIdx === toIdx || fromIdx < 0 || toIdx < 0 || fromIdx >= layers.length || toIdx >= layers.length) return;
  const [moved] = layers.splice(fromIdx, 1);
  layers.splice(toIdx, 0, moved);
  renderLayerList();
  renderStylePanel();
  // Re-renderiza todas as camadas no mapa
  layers.forEach(layerObj => {
    map.removeLayer(layerObj.leafletLayer);
    layerObj.leafletLayer.addTo(map);
  });
}

// --- Adiciona drag-and-drop na lista de camadas ---
function enableLayerDragDrop() {
  const ul = document.getElementById('layerList');
  ul.querySelectorAll('li').forEach((li, idx) => {
    li.draggable = true;
    li.ondragstart = (e) => {
      e.dataTransfer.setData('layerIdx', idx);
    };
    li.ondragover = (e) => {
      e.preventDefault();
      li.classList.add('bg-yellow-100');
    };
    li.ondragleave = () => {
      li.classList.remove('bg-yellow-100');
    };
    li.ondrop = (e) => {
      li.classList.remove('bg-yellow-100');
      const fromIdx = parseInt(e.dataTransfer.getData('layerIdx'));
      moveLayer(fromIdx, idx);
    };
  });
}

// Modifique renderLayerList para chamar enableLayerDragDrop
const originalRenderLayerList = renderLayerList;
renderLayerList = function() {
  originalRenderLayerList();
  enableLayerDragDrop();
};
  </script>
</body>
</html>
