<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador GeoJSON Interativo</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    
    <!-- Incluindo Tailwind CSS para estilização moderna e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Estilos básicos para o corpo e layout principal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            padding: 0;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh; /* Ocupa a altura total da viewport */
            overflow: hidden; /* Evita rolagem indesejada */
        }

        header {
            background-color: #1f2937;
            color: white;
            padding: 1rem;
            text-align: center;
            flex-shrink: 0; /* Impede que o cabeçalho seja comprimido */
        }

        .content-wrapper {
            display: flex;
            flex: 1; /* Permite que o wrapper ocupe o espaço restante */
            flex-direction: column;
            gap: 1rem;
            padding: 1rem;
            overflow: hidden; /* Esconde overflow para evitar barras de rolagem duplas */
        }

        /* Layout responsivo para o painel de controles e o mapa */
        @media (min-width: 1024px) {
            .content-wrapper {
                flex-direction: row; /* Layout horizontal em telas maiores */
            }
        }

        .controls {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            max-height: 50vh;
        }
        
        @media (min-width: 1024px) {
            .controls {
                flex: 0 0 320px; /* Largura fixa para o painel de controle */
                max-height: none;
            }
        }

        #map-and-editor-wrapper {
            flex: 1; /* Ocupa todo o espaço restante horizontalmente */
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 1024px) {
            #map-and-editor-wrapper {
                flex-direction: row; /* Layout horizontal para mapa e editor */
            }
        }

        #map {
            flex: 1; /* Ocupa o espaço restante dentro do wrapper */
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            min-height: 400px; /* Altura mínima para mobile */
        }

        .geojson-input-area {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            flex: 1; /* Ocupa o espaço restante dentro do wrapper */
        }

        .control-group {
            margin-bottom: 1rem;
        }

        input[type="range"] {
            width: 100%;
        }

        button {
            width: 100%;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
        }

        .primary-button {
            background-color: #3b82f6;
            color: white;
        }

        .primary-button:hover {
            background-color: #2563eb;
        }
        
        .secondary-button {
            background-color: #f3f4f6;
            color: #1f2937;
            border: 1px solid #d1d5db;
        }

        .secondary-button:hover {
            background-color: #e5e7eb;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .file-item:hover {
            background-color: #e5e7eb;
        }

        .file-item.active {
            background-color: #dbeafe;
            border-color: #93c5fd;
        }

        .file-item button {
            width: auto;
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }

        #geojsonTextarea {
            flex: 1;
        }
        
        .CodeMirror {
            border: 1px solid #eee;
            height: auto;
            min-height: 200px;
            border-radius: 0.5rem;
            flex: 1;
        }

        /* Message box em vez de alert() */
        #message-box {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            z-index: 1000;
            font-weight: 500;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

    </style>
</head>
<body class="bg-gray-100">
    <header>
        <h1>Visualizador GeoJSON Interativo</h1>
    </header>

    <div class="content-wrapper">
        <!-- Painel de Controles -->
        <div class="controls">
            <h2 class="text-xl font-bold mb-4">Controles</h2>
            
            <div class="control-group">
                <label for="geojsonFile" class="block text-gray-700">Carregar GeoJSON (arquivo):</label>
                <input type="file" id="geojsonFile" accept=".geojson,.json" multiple class="mt-1 block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700
                    hover:file:bg-blue-100 cursor-pointer">
            </div>

            <hr class="my-4">

            <h3 class="text-lg font-semibold mb-2">Arquivos Carregados</h3>
            <div id="file-list" class="mb-4">
                <p id="no-files-message" class="text-sm text-gray-500 text-center">Nenhum arquivo carregado.</p>
            </div>

            <hr class="my-4">

            <h3 class="text-lg font-semibold mb-2">Estilo do GeoJSON</h3>
            <div id="style-controls" class="hidden">
                <div class="control-group">
                    <label for="styleColor" class="block text-gray-700">Cor da Linha/Borda:</label>
                    <input type="color" id="styleColor" value="#3b82f6" class="w-full mt-1 h-10 rounded-lg">
                </div>
                <div class="control-group">
                    <label for="styleWeight" class="block text-gray-700">Espessura Linha/Borda (px): <span id="weightValue" class="font-mono">3</span></label>
                    <input type="range" id="styleWeight" min="0" max="10" step="1" value="3">
                </div>
                <div class="control-group">
                    <label for="styleOpacity" class="block text-gray-700">Opacidade Linha/Borda: <span id="opacityValue" class="font-mono">1.0</span></label>
                    <input type="range" id="styleOpacity" min="0" max="1" step="0.05" value="1">
                </div>
                <h4 class="text-sm font-medium mt-4">Para Polígonos:</h4>
                <div class="control-group">
                    <label for="styleFillColor" class="block text-gray-700">Cor do Preenchimento:</label>
                    <input type="color" id="styleFillColor" value="#3b82f6" class="w-full mt-1 h-10 rounded-lg">
                </div>
                <div class="control-group">
                    <label for="styleFillOpacity" class="block text-gray-700">Opacidade Preenchimento: <span id="fillOpacityValue" class="font-mono">0.2</span></label>
                    <input type="range" id="styleFillOpacity" min="0" max="1" step="0.05" value="0.2">
                </div>
                <h4 class="text-sm font-medium mt-4">Para Pontos (Círculos):</h4>
                <div class="control-group">
                    <label for="styleRadius" class="block text-gray-700">Raio do Ponto (px): <span id="radiusValue" class="font-mono">6</span></label>
                    <input type="range" id="styleRadius" min="1" max="20" step="1" value="6">
                </div>
            </div>
        </div>
        
        <!-- Wrapper para Mapa e Editor de Texto para que fiquem lado a lado -->
        <div id="map-and-editor-wrapper">
            <div id="map"></div>
            
            <div class="geojson-input-area">
                <h2 class="text-xl font-bold mb-4 text-center">Inserir GeoJSON (texto)</h2>
                <textarea id="geojsonTextarea"></textarea>
                <button id="renderTextButton" class="mt-4 primary-button">Renderizar do Texto</button>
                <div class="mt-4 flex flex-col sm:flex-row gap-2">
                    <button id="exportGeoJsonButton" class="primary-button">Exportar Tudo como GeoJSON</button>
                    <button id="exportImageButton" class="secondary-button">Exportar Mapa como PNG</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="message-box"></div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
    <script src="https://unpkg.com/leaflet-image@latest/leaflet-image.js"></script>

    <script>
        // Função para exibir mensagens ao usuário em vez de usar alert()
        const showMessage = (message, duration = 3000) => {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        };

        // Inicializa o mapa Leaflet
        const initialCoordinates = [-14.235004, -51.92528];
        const initialZoom = 4;
        const map = L.map("map").setView(initialCoordinates, initialZoom);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        }).addTo(map);

        // Armazenamento de todas as camadas GeoJSON carregadas
        let loadedLayers = [];
        let activeLayer = null;

        // Referências aos elementos da UI
        const fileInput = document.getElementById("geojsonFile");
        const fileListContainer = document.getElementById("file-list");
        const noFilesMessage = document.getElementById("no-files-message");
        const styleControls = document.getElementById("style-controls");
        const geojsonTextarea = document.getElementById("geojsonTextarea");
        const renderTextButton = document.getElementById("renderTextButton");
        const exportGeoJsonButton = document.getElementById("exportGeoJsonButton");
        const exportImageButton = document.getElementById("exportImageButton");
        const weightValueSpan = document.getElementById("weightValue");
        const opacityValueSpan = document.getElementById("opacityValue");
        const fillOpacityValueSpan = document.getElementById("fillOpacityValue");
        const radiusValueSpan = document.getElementById("radiusValue");
        
        // Inicializa o CodeMirror para o editor de texto GeoJSON
        const geojsonEditor = CodeMirror.fromTextArea(geojsonTextarea, {
            mode: "application/json",
            theme: "material-darker",
            lineNumbers: true,
            lineWrapping: true,
            matchBrackets: true,
            autoCloseBrackets: true,
            indentUnit: 2,
            tabSize: 2,
        });

        // Valores de estilo padrão
        const defaultStyle = {
            color: "#3b82f6",
            weight: 3,
            opacity: 1.0,
            fillColor: "#3b82f6",
            fillOpacity: 0.2,
            pointRadius: 6,
        };
        
        // Inicializa os controles de estilo com os valores padrão
        const styleColorInput = document.getElementById("styleColor");
        const styleWeightInput = document.getElementById("styleWeight");
        const styleOpacityInput = document.getElementById("styleOpacity");
        const styleFillColorInput = document.getElementById("styleFillColor");
        const styleFillOpacityInput = document.getElementById("styleFillOpacity");
        const styleRadiusInput = document.getElementById("styleRadius");
        
        styleColorInput.value = defaultStyle.color;
        styleWeightInput.value = defaultStyle.weight;
        styleOpacityInput.value = defaultStyle.opacity;
        styleFillColorInput.value = defaultStyle.fillColor;
        styleFillOpacityInput.value = defaultStyle.fillOpacity;
        styleRadiusInput.value = defaultStyle.pointRadius;

        // Função para atualizar os valores dos spans
        const updateRangeValueSpans = () => {
            if (weightValueSpan) weightValueSpan.textContent = styleWeightInput.value;
            if (opacityValueSpan) opacityValueSpan.textContent = styleOpacityInput.value;
            if (fillOpacityValueSpan) fillOpacityValueSpan.textContent = styleFillOpacityInput.value;
            if (radiusValueSpan) radiusValueSpan.textContent = styleRadiusInput.value;
        };

        // Função para aplicar o estilo a uma camada
        const applyStyleToLayer = (layerObject) => {
            const { layer, style } = layerObject;
            
            // Verifica o tipo de geometria para aplicar o estilo correto
            const geojsonType = layer.toGeoJSON().features[0]?.geometry?.type;
            const isPoint = geojsonType && (geojsonType === "Point" || geojsonType === "MultiPoint");
            
            // Aplica o estilo baseado no tipo de geometria
            if (isPoint) {
                layer.eachLayer(l => {
                    if (l instanceof L.CircleMarker) {
                        l.setStyle({
                            radius: style.pointRadius,
                            fillColor: style.fillColor,
                            color: style.color,
                            weight: style.weight,
                            opacity: style.opacity,
                            fillOpacity: style.fillOpacity,
                        });
                    }
                });
            } else {
                layer.setStyle({
                    color: style.color,
                    weight: style.weight,
                    opacity: style.opacity,
                    fillColor: style.fillColor,
                    fillOpacity: style.fillOpacity,
                });
            }
        };

        // Função para ler os valores dos controles e atualizar o estilo da camada ativa
        const updateActiveLayerStyle = () => {
            if (!activeLayer) return;

            activeLayer.style.color = styleColorInput.value;
            activeLayer.style.weight = parseInt(styleWeightInput.value);
            activeLayer.style.opacity = parseFloat(styleOpacityInput.value);
            activeLayer.style.fillColor = styleFillColorInput.value;
            activeLayer.style.fillOpacity = parseFloat(styleFillOpacityInput.value);
            activeLayer.style.pointRadius = parseInt(styleRadiusInput.value);
            
            applyStyleToLayer(activeLayer);
            updateRangeValueSpans();
        };

        // Adiciona listeners para os controles de estilo
        [styleColorInput, styleWeightInput, styleOpacityInput, styleFillColorInput, styleFillOpacityInput, styleRadiusInput].forEach(input => {
            input.addEventListener('input', updateActiveLayerStyle);
        });

        // Função para adicionar uma nova camada GeoJSON ao mapa
        const addGeoJsonToMap = (geojsonData, fileName) => {
            // Cria uma camada Leaflet e aplica um estilo
            const newLayer = L.geoJSON(geojsonData, {
                style: (feature) => {
                    const type = feature.geometry.type;
                    const isPoint = type === "Point" || type === "MultiPoint";
                    return isPoint ? { ...defaultStyle, radius: defaultStyle.pointRadius } : defaultStyle;
                },
                pointToLayer: (feature, latlng) => {
                    return L.circleMarker(latlng);
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = "<h4>Propriedades</h4><ul>";
                        for (const key in feature.properties) {
                            popupContent += `<li><strong>${key}:</strong> ${feature.properties[key]}</li>`;
                        }
                        popupContent += "</ul>";
                        layer.bindPopup(popupContent);
                    }
                }
            }).addTo(map);

            // Armazena a camada no nosso array de controle
            const newLayerObject = {
                id: Date.now(),
                name: fileName,
                data: geojsonData,
                layer: newLayer,
                style: { ...defaultStyle }
            };
            loadedLayers.push(newLayerObject);

            // Adiciona um listener de clique na camada para ativá-la para edição
            newLayer.on('click', () => {
                setActiveLayer(newLayerObject);
            });
            
            // Ativa a camada recém-adicionada
            setActiveLayer(newLayerObject);

            // Ajusta o mapa para a nova camada
            if (newLayer.getBounds().isValid()) {
                map.fitBounds(newLayer.getBounds());
            }

            // Esconde a mensagem de "nenhum arquivo"
            noFilesMessage.classList.add("hidden");
        };

        // Função para definir a camada ativa
        const setActiveLayer = (layerObject) => {
            if (activeLayer) {
                // Remove a classe de ativo do item anterior
                const oldItem = document.querySelector(`.file-item[data-id="${activeLayer.id}"]`);
                if (oldItem) oldItem.classList.remove('active');
            }

            activeLayer = layerObject;
            
            // Atualiza a interface de estilo com os valores da nova camada ativa
            styleColorInput.value = activeLayer.style.color;
            styleWeightInput.value = activeLayer.style.weight;
            styleOpacityInput.value = activeLayer.style.opacity;
            styleFillColorInput.value = activeLayer.style.fillColor;
            styleFillOpacityInput.value = activeLayer.style.fillOpacity;
            styleRadiusInput.value = activeLayer.style.pointRadius;
            
            updateRangeValueSpans();
            styleControls.classList.remove("hidden");

            // Adiciona a classe de ativo no item de arquivo
            const newItem = document.querySelector(`.file-item[data-id="${activeLayer.id}"]`);
            if (newItem) newItem.classList.add('active');
        };

        // Função para remover uma camada
        const removeLayer = (layerId) => {
            const index = loadedLayers.findIndex(l => l.id === layerId);
            if (index !== -1) {
                const layerObject = loadedLayers[index];
                map.removeLayer(layerObject.layer);
                loadedLayers.splice(index, 1);
                
                // Se a camada removida era a ativa, redefine a camada ativa
                if (activeLayer && activeLayer.id === layerId) {
                    activeLayer = null;
                    styleControls.classList.add("hidden");
                }
                
                updateFileListUI();
                showMessage(`Arquivo "${layerObject.name}" removido.`);
            }
        };
        
        // Função para renderizar a lista de arquivos na interface
        const updateFileListUI = () => {
            fileListContainer.innerHTML = '';
            if (loadedLayers.length === 0) {
                noFilesMessage.classList.remove("hidden");
                return;
            }

            loadedLayers.forEach(layerObject => {
                const fileItem = document.createElement('div');
                fileItem.className = `file-item ${activeLayer && activeLayer.id === layerObject.id ? 'active' : ''}`;
                fileItem.dataset.id = layerObject.id;
                fileItem.innerHTML = `
                    <span class="text-sm font-medium truncate">${layerObject.name}</span>
                    <button class="remove-btn bg-red-500 hover:bg-red-600 text-white text-xs px-2 py-1 rounded-full">Remover</button>
                `;
                fileItem.addEventListener('click', () => setActiveLayer(layerObject));
                fileItem.querySelector('.remove-btn').addEventListener('click', (e) => {
                    e.stopPropagation(); // Previne o evento do pai
                    removeLayer(layerObject.id);
                });
                fileListContainer.appendChild(fileItem);
            });
        };

        // Listener para carregar arquivos
        fileInput.addEventListener("change", (event) => {
            const files = event.target.files;
            if (files.length === 0) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const geojsonData = JSON.parse(e.target.result);
                        addGeoJsonToMap(geojsonData, file.name);
                        updateFileListUI();
                    } catch (error) {
                        showMessage(`Erro ao carregar o arquivo "${file.name}". Verifique se o formato GeoJSON está correto.`);
                        console.error("Erro ao processar o arquivo GeoJSON:", error);
                    }
                };
                reader.readAsText(file);
            });
        });

        // Listener para renderizar do editor de texto
        renderTextButton.addEventListener("click", () => {
            try {
                const geojsonString = geojsonEditor.getValue();
                if (!geojsonString.trim()) {
                    showMessage("A área de texto está vazia.");
                    return;
                }
                const geojsonData = JSON.parse(geojsonString);
                addGeoJsonToMap(geojsonData, "Editor de Texto");
            } catch (error) {
                showMessage(`Erro de sintaxe no GeoJSON: ${error.message}`);
                console.error("Erro ao processar o GeoJSON do texto:", error);
            }
        });

        // Função para exportar os dados
        const triggerDownload = (content, fileName, contentType) => {
            const a = document.createElement("a");
            const file = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(a.href);
            document.body.removeChild(a);
        };

        // Listener para exportar GeoJSON
        exportGeoJsonButton.addEventListener("click", () => {
            if (loadedLayers.length === 0) {
                showMessage("Nenhum dado GeoJSON para exportar.");
                return;
            }

            const allFeatures = [];
            loadedLayers.forEach(layerObj => {
                // Adiciona a feature original (sem a estilização)
                const features = (layerObj.data.features || [layerObj.data]);
                features.forEach(feature => {
                    const styledFeature = JSON.parse(JSON.stringify(feature));
                    // Adiciona o estilo como uma propriedade para que seja exportado
                    styledFeature.properties = styledFeature.properties || {};
                    styledFeature.properties.style = {
                        color: layerObj.style.color,
                        weight: layerObj.style.weight,
                        opacity: layerObj.style.opacity,
                        fillColor: layerObj.style.fillColor,
                        fillOpacity: layerObj.style.fillOpacity,
                        pointRadius: layerObj.style.pointRadius
                    };
                    allFeatures.push(styledFeature);
                });
            });

            const unifiedGeoJson = {
                "type": "FeatureCollection",
                "features": allFeatures
            };
            
            const geojsonString = JSON.stringify(unifiedGeoJson, null, 2);
            triggerDownload(geojsonString, "mapa_unificado.geojson", "application/json");
            showMessage("GeoJSON unificado exportado com sucesso.");
        });

        // Listener para exportar imagem
        exportImageButton.addEventListener("click", () => {
            if (!map) {
                showMessage("O mapa não foi inicializado.");
                return;
            }
            if (loadedLayers.length === 0) {
                showMessage("Não há nada para exportar.");
                return;
            }
            
            leafletImage(map, (err, canvas) => {
                if (err) {
                    showMessage("Erro ao exportar o mapa como imagem.");
                    console.error("Erro ao exportar imagem:", err);
                    return;
                }
                const dataUrl = canvas.toDataURL("image/png");
                triggerDownload(dataUrl, "mapa_exportado.png", "image/png");
                showMessage("Mapa exportado como imagem PNG.");
            });
        });
    </script>
</body>
</html>
